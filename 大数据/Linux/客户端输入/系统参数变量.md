## 系统参数变量

Shell 提供了一些特殊的参数变量，他们会保存命令行参数相关的信息，在脚本中会用到这些变量。下面通过例子说明每个变量的使用方式。
### 一、参数计算

如果命令行参数个数较少，可以采用上面例子的方式对每一个参数进行测试，如果命令
行参数个数有多个，那么逐个测试参数就比较繁琐了。Shell 提供了另外一个内置变量`$#`，
用来保存命令行参数的个数，**注意：$0 参数不包含在内**。可以通过这个变量判断参数的
个数是否符合要求。$#变量可以向普通变量一样在脚本中引用。

* 1、下面通过一个简单的例子说明`$#`变量的使用方式。

      #!/bin/bash
      # 将参数个数赋值给变量
      sum=$#
      echo "Parameter number is $sum" 
     
     * 控制台显示：
     
            $ bash75.sh a b c d e f g
            Parameter number is 7
            $ bash75.sh 1 2 3
            Parameter number is 3
            $ bash75.sh
            Parameter number is 0
            
* 2、修改上面的例子，通过判断参数的个数来决定脚本是否执行，例子：

        #!/bin/bash
        # 判断命令行参数个数是否等于 2
        if [ $# -eq 2 ]
        then
            product=$[ $1 * $2 ]
        # 判断命令行参数是否小于 2
        elif [ $# -lt 2 ]
        then
            echo "Missing parameter!" 
            # 终止脚本执行
            exit 1
        # 判断命令行参数个数是否大于 2
        elif [ $# -gt 2 ]
        then
            echo "Parameter number error!" 
            # 终止脚本执行
            exit 1
        fi
        echo "The product of $1 and $2 is $product" 

    * 控制台显示：

          $ bash76.sh 12 3 22
          Parameter number error!
          $ bash76.sh 
          Missing parameter!
          $ bash76.sh 12 3
          The product of 12 and 3 is 36

* 3、另外，变量`$#`还有一个特殊的用途，因为`$#`变量保存的是参数的个数，理论上可以通过`${$#}`来访问最后一个变量，
而不需要知道参数的数量。但是 Bash Shell 脚本中的大括号内不能使用`$`符，所以`使用!号代替大括号内的$符`。下面通过例子说明。例：bash77.sh：

      #!/bin/bash
      # 大括号中不能使用$符，所以输出的结果错误
      echo "${$#}"
      # 使用!号替代$符
      echo "${!#}" 

  * 控制台显示：
  
        $ bash77.sh a b c d
        5897
        d
        $ bash77.sh 23
        5898
        23
        $ bash77.sh
        5900
        ./bash77.sh
        
  * 可以看出`${$#}`的输出不正确，而`${!#}`的输出正确，输出的是最后一个参数值。但是需要注意的是当脚本没有命令行参数时，`${!#}`输出的是带目录的脚本名称。

### 二、取得所有的参数

* 对于命令行参数还可以采用其他的方式访问，**一次性全部读取然后循环遍历**。
    * Shell 提供了两个特殊变量` $* 和 $@ `对命令行参数快速访问。
      * Shell 会将所有的命令行参数分配给这两个变量，通过这两个变量就可以循环访问命令行所有的参数。

* ` $* 变量 和 $@ 变量`的区别：

  * `$* 变量`将命令行提供的所有参数当成一个完整的单词保存，这个完整的单词包含所有的命令行参数，` $* 变量`会将这个完整的单词当做一个对象或一个参数而不是多个对象或单词。

  * `$@ 变量`会将命令行提供的所有参数当成同一个字符串中的多个独立的单词，允许使用 for 循环对每个参数进行遍历。

  * 下面通过几个例子说明变量` $* 和 $@ `区别是使用方式。

* 1、第一个例子只是简单的将两个变量的值输出到控制台，通过例子可以看到两个变量都将命令行的所有参数都保存到了变量中。例子：

      #!/bin/bash
      # 输出变量$*到控制台
      echo "\$*: $*" 
      # 输出变量$@到控制台
      echo "\$@: $@" 
      
     * 控制台显示：
     
            $ bash78.sh a b c d e f g
            $*: a b c d e f g
            $@: a b c d e f g
            
     * 从这个例子中好像看不到两个参数的区别，都将命令行所有的参数都保存到了变量中。

* 2、下面的例子采用 for 循环遍历两个变量的参数，**注意：在 for 循环中没有使用双引号，注意有什么区别**。例：bash79.sh：

        #!/bin/bash
        # 计数器
        count=1
        # 循环遍历变量$*
        for var1 in $*
        do
            echo "\$* $count: $var1" 
            # 计数器加一
            count=$[$count + 1 ]
        done
        # 计数器复位
        count=1
        # 循环遍历变量$@
        for var2 in $@
        do
            echo "\$@ $count: $var2" 
            # 计数器加一
            count=$[ $count + 1 ]
        done
        
  * 控制台显示：

            $ bash79.sh a b c d e f g
            $* 1: a
            $* 2: b
            $* 3: c
            $* 4: d
            $* 5: e
            $* 6: f
            $* 7: g
            $@ 1: a
            $@ 2: b
            $@ 3: c
            $@ 4: d
            $@ 5: e
            $@ 6: f
            $@ 7: g
            
  * 从上面的例子可以看出，如果两个变量在 for 循环中没有加双引号，从输出可以看出两个变量没有区别。

* 3、下面的例子中在 for 循环中将两个变量加上双引号，注意输出的变化。          

      #!/bin/bash
      # 计数器
      count=1
      # 循环遍历变量$*
      for var1 in "$*"
      do
          echo "\$* $count: $var1" 
          # 计数器加一
          count=$[$count + 1 ]
      done
      # 计数器复位
      count=1
      # 循环遍历变量$@
      for var2 in "$@"
      do
          echo "\$@ $count: $var2" 
          # 计数器加一
          count=$[ $count + 1 ]
      done

    * 控制台显示：
    
          $ bash80.sh a b c d e f g
          $* 1: a b c d e f g
          $@ 1: a
          $@ 2: b
          $@ 3: c
          $@ 4: d
          $@ 5: e
          $@ 6: f
          $@ 7: g
    * 从输出可以看出，`$* 变量`只循环了一次，将所有的参数当成一个完整的单词，而`$@ 变量`循环多次，将所有的命令行参数逐个输出到控制台。

    * 通过上面的例子可以看出，`$* 变量`将所有的命令行参数当成一个参数，而`$@ 变量`会单独处理每一个参数，通过 for 循环可以变量命令行参数。

### 三、命令行参数的移动

* **Shell 提供了一个`命令 shift`，这个命令可以将命令行参数向左移动，将左面的参数覆盖**。这种方式处理命令行参数较为常用，不需要循环遍历命令行参数。

    * 使用 shift 命令时，命令行参数的个数会自动减一，参数$4 的值会移动到$3，$3 参数的
    值会移动到$2，参数$2 的值移动到$1，而$1 参数的值被删除。

    * 注意：变量$0 的值不会改变。这个命令的好处是在代码中不需要循环遍历命令行参数，并且在代码中只需要访问$1，每执行一次 shift 命令，后面的参数会填充$1 变量。

* 1、下面通过一个简单的例子说明shift 命令的基本用法。
例子：

      #!/bin/bash
      # 保存参数的个数
      count=$#
      # 循环
      for (( i = 1 ; i <= $count ; i++ ))
      do
          # 输出参数个数和变量$1 的值
          echo "\$#: $# \$1: $1" 
          # 左移一位参数，变量$2 的值填充变量$1，第一个参数被清除
          # 命令行参数的个数减一
          shift
      done
      # 输出$0 变量的值，$0 变量的值不会改变
      echo "\$0: $0" 
     
   * 控制台显示：
   
          $ bash81.sh a b c d e f g
          $#: 7 $1: a
          $#: 6 $1: b
          $#: 5 $1: c
          $#: 4 $1: d
          $#: 3 $1: e
          $#: 2 $1: f
          $#: 1 $1: g
          $0: ./bash81.sh

   * 命令 shift 执行后，参数个数减一并且变量$1 的值会被后面的值依次填充。

* 2、下面的例子说明 shift 命令在脚本中的常用方式。

        #!/bin/bash
        # 计数器
        count=1
        # 循环，判断变量$1 是否非空
        while [ -n "$1" ]
        do
            echo "count: $count \$1: $1" 
            # 计数器加一
            count=$[ $count + 1 ]
            # 左移一位
            shift
        done
        
    * 控制台显示：
    
            $ bash82.sh a b c d e f g
            count: 1 $1: a
            count: 2 $1: b
            count: 3 $1: c
            count: 4 $1: d
            count: 5 $1: e
            count: 6 $1: f
            count: 7 $1: g

  ### 注意：引用变量时最好加上双引号。

* 3、命令 shift 还可以使用参数，如：shift 2。

        #!/bin/bash
        count=1
        while [ -n "$1" ]
        do
            echo "count: $count \$1: $1" 
            count=$[ $count + 1 ]
            # 左移两位，$3 的值移动到$1
            shift 2
        done
        
  * 控制台显示：
  
        $ bash83.sh 1 2 3 4 5 6 7 8
        count: 1 $1: 1
        count: 2 $1: 3  
        count: 3 $1: 5
        count: 4 $1: 7

  * shift 命令后面的参数是一次移动几位，上面的例子的参数是 2，$3 移动到$1，后面的参数向前移动两位，以此类推，变量$1 和变量$2 的值清除。需要注意的是**被清除的参数不可恢复**。
