## 数据备份与一致性

### CAP理论

分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。

分布式系统最大的难点，就是各个节点的状态如何同步。而CAP理论是这方面的基本定理，也是理解分布式系统的起点。

任何分布式系统在可用性、一致性、分区容错性方面，不能兼得，最多只能兼顾其中的两个，因此任何分布式系统的设计只是三者中的不同取舍而已。

以下是分布式系统三个指标：

* Consistency
* Availability
* Partition tolerance（分区容错）

#### Consistency

一致性，访问所有节点得到的数据应该是一样的。

这里的一致性是强一致性，也就是数据更新完，访问任何节点看到的数据完全一致。不同于弱一致性，最终一致性。

#### Availability

可用性，所有节点都保持高可用性。

注意，这里的高可用还包括不能出现延迟，比如如果节点B由于等待数据同步而阻塞请求，那么节点B就不满足高可用性。

也就是，任何没有发生故障的服务必须在有限的时间内返回合理的结果集。

#### Partition tolerance

分区容错，由于网络是不可靠的，所有节点之间可能出现无法通信的情况。而在节点不能通信时，要保证系统可以继续正常服务。

由于网络的不可靠性质，大多数开源的分布式系统都会实现P，也就是分区容错性，之后在C和A中做选择。

#### 对CAP原理的一些常见的理解误区

误区：有很多文章说CAP原理是分布式系统的基石。

但其实CAP原理是对分布式数据存储系统的一个定论。

我们假设一个分布式系统各个节点都读写同一个mysql实例，那么对于这个分布式系统来说，讨论CAP原理是没有意义的。因为各个节点之间可以不用进行数据复制来通信，满足分区容错性，可以随时响应请求，满足可用性，同时因为访问的是一个数据库实例，本身已经保证了数据一致性。

因此，讨论CAP原理更多的是针对那些有数据存储、数据复制场景的分布式存储系统，也就是我们熟悉的NoSql数据库。

由于我们大多数人都不会去设计一款新的NoSQL数据库来使用，更多的是使用现成的NoSql开源系统进行数据的存储，比如Hbase、MongoDB等，所以大多数时候，其实我们都用不上CAP原理。

虽然用不上，但是了解一下还是没有坏处的。

[CAP原理](https://www.jianshu.com/p/482ba491a760)

### 幂等性

#### 什么是幂等性？

HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有相同的效果。

也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

需要注意以下几点：

1. 幂等不仅仅只是一次（或多次）请求对资源没有副作用（比如查询数据库操作，没有增删改，因此没有对数据库有任何影响）。
2. 幂等还包括第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。
3. 幂等关注的是以后的多次请求是否对资源产生的副作用，而不关注结果。
4. 网络超时等问题，不是幂等的讨论范围。

幂等性是系统服务对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。

#### 什么情况下需要幂等？

业务开发中，经常会遇到重复提交的情况，无论是由于网络问题无法收到请求结果而重新发起请求，或是前端的操作抖动而造成重复提交情况。 在交易系统，支付系统这种重复提交造成的问题有尤其明显，比如：

1. 用户在APP上连续点击了多次提交订单，后台应该只产生一个订单；
2. 向支付宝发起支付请求，由于网络问题或系统BUG重发，支付宝应该只扣一次钱。 **很显然，声明幂等的服务认为，外部调用者会存在多次调用的情况，为了防止外部多次调用对系统数据状态的发生多次改变，将服务设计成幂等。**

#### 防重复提交策略

乐观锁：设计表结构时，加一个version字段保证幂等。

防重表：使用订单号No作为去重表的唯一索引，通过插入订单号和删除订单号，起到加锁和释放锁的功能。

分布式锁：防重表，可以使用分布式锁进行代替，比如Redis。相比于去重表，将并发判断放到缓存中，较为高效。同一时间只能完成一次请求。

token令牌：需要两次请求。第一次申请token，并保存在Redis缓存中，作为请求逻辑处理前的一个信物。通过查询缓冲中存在这个信物，来判断是第一次请求，不存在则是非法请求。

支付缓冲区：优点是同步转异步，高吞吐；缺点是不能及时返回支付结果，需要监听支付结果的异步返回。

### 一致性模型

分布式架构一定绕不开“一致性”问题，而一致性又分为数据一致性和事务一致性两种情况，下面讨论数据一致性。

复制（备份）是导致出现数据一致性问题的唯一原因。

如果只用一台数据库来处理所有的写入和读取请求，就一定不会存在数据一致性问题。

在大型项目中，需要将一份数据存储在超过一台数据库中（复制），有以下好处：

```
1 即使一部分数据库出现故障，系统也能正常工作（高可用）
2 使数据与用户在地理上接近（降低延迟）
3 扩展可以处理读请求的机器数量（可扩展性，提高读取吞吐量）
```

以下讨论，假设每台机器的空间足够保存整个数据集（否则将会引入“分区”的概念），使用单领导者的主从复制算法，即***只有一台数据库可以处理写请求***（称为领导者或主库），所有数据库都可以处理读请求（除主库外其他都是追随者或从库）。

#### 强一致性 与 弱一致性

其实只有两类数据一致性，强一致性和弱一致性。

强一致性也叫线性一致性。其他所有一致性都是弱一致性的特殊情况。
强一致性，即复制是同步的：主库收到用户的数据更新请求，某时刻，主库又会将数据变更同步给从库，并等待确认从库同步写入成功，最后，主库通知用户更新成功。

可以保证主从库数据一致，如果主库宕机，仍可以保证数据完整；但如果从库宕机或网络阻塞，主库就无法完成写入操作。

实践中，我们通常***使一个从库同步的，而其他的则是异步的***。如果这个同步的从库出现问题，则使另一个异步从库进行同步，这样可以确保总是有两个节点拥有完整数据（主库和同步的从库）。这种配置叫半同步。

弱一致性，即复制是异步的：主库写入成功后，不等待从库的响应，直接返回用户更新成功。



#### 最终一致性

单领导者的主从复制算法要求所有写入都由单个节点处理，但只读查询可以由任何节点处理。对于读多写少的场景，我们往往创建很多从库，并将读请求分散到所有的从库上去。这样能减小主库的负载，并允许向最近的节点发送读请求。当然这只适用于***异步复制***——如果尝试同步复制，则单个节点故障将使整个系统无法写入。

当用户从**异步从库**读取时，**如果此异步从库落后，他可能会看到过时的信息。**这种不一致只是一个**暂时的状态**——如果等待一段时间，从库最终会赶上并与主库保持一致。这称为**最终一致性。**

**最终**两个字用得很微妙，因为从写入主库到同步至从库之间的延迟，可能仅仅是几分之一秒，也可能是几个小时。

#### 读写一致性

#### 单调读

#### 因果一致性





[知乎一致性模型](https://zhuanlan.zhihu.com/p/67949045)



### 一致性协议

#### 一致性算法Paxos

解决了一致性问题。

原理：少数服从多数，标准的鸽笼原理/抽屉原理，同时还会根据节点身份级别判断是否需要应答。

追忆：前提是在没有拜占庭将军问题基础上，即网络信道可靠，不存在信息丢失和篡改的情况。

[一致性协议-博客](https://www.cnblogs.com/stateis0/category/1206895.html)

